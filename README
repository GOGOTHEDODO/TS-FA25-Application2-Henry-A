# Task Timing and Jitter: 
## Compare the timing of the LED blink and console print tasks with that of the sensor task. How regular is each task’s period in practice? For the sensor task (using vTaskDelayUntil), do the sensor readings and alert messages occur at consistent intervals (e.g. every 500 ms)? In contrast, do you observe any drift or variation in the LED blink or print intervals over time? Explain why vTaskDelayUntil provides a more stable period for the sensor task, referencing how it calculates the next wake-up tick based on an absolute time reference. What might cause jitter in the LED or print task periods when using vTaskDelay? (Hint: consider the effect of the sensor task running at the moment they are ready to run, and how that might delay them slightly.)

Each task is perfectly regular. The sensor task and the LED/print tasks all occur at constant internals. There was no drift observed for the LED/print tasks. vTaskDelayUntil provides more regular periods as it accounts for the time it takes for the task to run. For variable length tasks, the task can start to drift as the time between tasks is equal to period +/- (tasktime). Addtionally, if the led task is premepted before reaching the delay, then the time it spent idle isn't accounted for and would also add to the drift. 

# Priority-Based Preemption: 
## Describe a scenario observed in your running system that demonstrates FreeRTOS’s priority-based preemptive scheduling. For example, what happens if the console print task is about to print (or even mid-way through printing) exactly when the sensor task’s next period arrives? Does the sensor task interrupt the print task immediately, or does it wait? Based on your understanding of FreeRTOS, which task would the scheduler choose to run at a moment when both become Ready, and why? Provide a brief timeline or example (using tick counts or event ordering) to illustrate the preemption. (If you didn’t explicitly catch this in simulation, answer conceptually: assume the print task was running right when the sensor task unblocked – what should happen?)

Aftering altering the print task to pirnt continously, the sensor task never split a print task partway through the output. However, the peroid of the sensor task was delayed by 10ms every so often, and the LED was starved. So it seems that printf is atomic in the sense that while sending output to the stdio, the thread can not be premepted until the print task is finished and instead the sensor task is held until print is finished and then runs.  If both are ready at the same time the sensor task would run first as it has a higher priority. 

if the print task was set to run at 10 ticks and the sensor was to run at 15 ticks, then the print task would get the function call, which might be 2 ticks, initalize the time variables which is another 2 ticks, and finally from tick 14-15 it would initalize i for the for loop I added, then the senor task would be ready. The scheduler would compare priorities, and then block the print task, let the sensor run for its entirety, then go back and continue where it left off in the print task. 

# Effect of Task Execution Time: 
## In our design, all tasks have small execution times (they do minimal work before blocking again). Suppose the sensor task took significantly longer to execute (for instance, imagine it performed a complex calculation taking, say, 300 ms of CPU time per cycle). How would that affect the lower-priority tasks? Discuss what would happen if the sensor task’s execution time sometimes exceeds its period (i.e., it can’t finish its work before the next 500 ms tick). What symptoms would you expect to see in the system (e.g. missed readings, delayed LED toggles, etc.)? Relate this to real-time scheduling concepts like missed deadlines or CPU utilization from the RTOS theory (Chapters 3 and 6 of the Harder textbook). What options could a system designer consider if the high-priority task started starving lower tasks or missing its schedule (think about reducing workload, adjusting priorities, or using two cores)?

If the sensor task takes noticably more time, then both the print and led tasks would starve and miss deadlines. If the sensor task cannot complete its task its in period then vTaskDelayUntil will simply re run the task, which would cause the task to run continously and starve all other lower priority tasks. This would cause the one tsk to hog all the CPU utilization and cause not only the sensor task to miss its deadline, but all other lower priority tasks as well. If this is a hard real time system then the system is acomplishing nothing while running 100%. 

The simplest Solution would be just to exstend the deadline, giving the sensor task more time to work on it. Baring that, the most expensive solution is to add another core. This would allow the other tasks to run on the second core while the sensor runs on its own core. To prevent the sensor task from missing its deadline, we can optomize the algorithm, offload some of its load onto other task, or adjust priorities such that other task can run inbetween the sensor running its calculations. 

# vTaskDelay vs vTaskDelayUntil: 
## Why did we choose vTaskDelayUntil for the sensor task instead of using vTaskDelay in a simple loop? Explain in your own words the difference between these two delay functions in FreeRTOS, and the specific problem that vTaskDelayUntil solves for periodic real-time tasks. Consider what could happen to the sensor sampling timing over many iterations if we used vTaskDelay(500 ms) instead – how might small errors accumulate? Also, for the LED blink task, why is using vTaskDelay acceptable in that context? (Think about the consequences of slight timing drift for a status LED vs. a sensor sampling task.)

We chose to use vTaskDelayUntil because it accounts for the time it takes to process the task while taskDelay simply delays a fixed amount appended after the task prcesses. vtaskDelayUntil takes in a pointer to the previous time the task is called, and the global time you would like it to delay to. for variable length functions, vTaskDelayUntil helps keep a consistant time peroid, as the total time peroid is (delay-taskTime) + taskTime, vs regular delay has a delay of delay + tasktime. If we used regular delay then over time the time it takes to process the sensor task will add up and the sensor task will slowly drift off schedule. Using regular delay for the LED task is acceptable as toggling the LED takes at most like 30 clock cycles and thus is so short of a task that the time peroid is not meaningfully impacted. 

# Thematic Integration Reflection: 
## Relate the functioning of your three tasks to a real-world scenario in one of the thematic contexts (Space Systems, Healthcare, or Hardware Security). Describe an example of what each task could represent. Explain how task priority might reflect the importance of that function in the real system (e.g. why the sensor monitoring is high priority in a medical device).

For my real world system, I chose a earthquake detector. According to the interwebs, it is possible to detect seismic activity using alterations in the signal transfer in fiber optic cabling. The LED task is assigned as a simple running notifier. It lets the researchers know the systems has power and is currently listening for activity. This is low priorty becuase if anything else is running, then we don't need a on indicator. The print task logs that there was no major errors at the current time stamp, and is meduim priority. This is more import than the led task, but the sensor reading itself is still more import. 
Lastly the light sensor detects the light from the cables to detemrine if there's sizable seismic activity. This is the highest priority as earthquakes are fast and needs to be detected as soon as possible. 

source:
Fiber optic cables detect and characterize earthquakes. (n.d.). California Institute of Technology. https://www.caltech.edu/about/news/fiber-optic-cables-detect-and-characterize-earthquakes

# Bonus: 
## design an experiment which causes starvation in the system (e.g., sensor task never gives time to the other tasks). Describe the code you used and the results. Leave the code in your environment but comment it out. Return your code for submission to a working ideal state.

It was very easy to cause a starvation event, i simply had the sensor task compute the first 30 fibinati numbers the long way in a recursive loop. This provided enough busy work to delay the task until the next scheduled deadline has passed. 